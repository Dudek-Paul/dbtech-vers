package de.htwberlin.dbtech.aufgaben.ue03;

/*
  @author Ingo Classen
 */

import de.htwberlin.dbtech.exceptions.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.sql.*;
import java.time.temporal.ChronoUnit;

/**
 * VersicherungJdbc
 */
public class VersicherungService implements IVersicherungService {
    private static final Logger L = LoggerFactory.getLogger(VersicherungService.class);
    private Connection connection;

    @Override
    public void setConnection(Connection connection) {
        this.connection = connection;
    }

    private Connection useConnection() {
        if (connection == null) {
            throw new DataException("Connection not set");
        }
        return connection;
    }

    @Override
    public void createDeckung(Integer vertragsId, Integer deckungsartId, BigDecimal deckungsbetrag) {
        L.info("[createDeckung] start -> vertragsId: " + vertragsId + " deckungsartId: " + deckungsartId + " deckungsbetrag: " + deckungsbetrag);

        // Wenn vertragsId kein gültiger Primärschlüssel für Verträge ist.
        if (!existiertVertragIDInDB(vertragsId)) {
            throw new VertragExistiertNichtException(vertragsId);
        }

        // Wenn deckungsartId kein gültiger Primärschlüssel für Deckungsarten ist.
        if (!existiertDeckungsartInDB(deckungsartId)) {
            throw new DeckungsartExistiertNichtException(deckungsartId);
        }

        // Wenn die Deckungsart nicht für das Produkt des Vertrags passt.
        if (!deckungsartPasstZuProdukt(vertragsId, deckungsartId)) {
            throw new DeckungsartPasstNichtZuProduktException(vertragsId, deckungsartId);
        }

        // Wenn der Deckungsbetrag für die gegebene Deckung nicht angeboten wird.
        if (!existiertDeckungsbetragInDB(deckungsartId)) {
            throw new UngueltigerDeckungsbetragException(deckungsbetrag);
        }

        // Wenn der Deckungsbetrag für die gegebene Deckung nicht angeboten wird.
        if (!existiertDeckungsbetragInDB(deckungsartId, deckungsbetrag)) {
            throw new UngueltigerDeckungsbetragException(deckungsbetrag);
        }

        // Wenn für ein Deckungsbetrag kein Deckungspreis vorliegt.
        if (!exisitiertDeckungspreisFürDeckungsbetrag(deckungsartId)) {
            throw new DeckungspreisNichtVorhandenException(deckungsbetrag);
        }

        // Wenn das Vertragsdatum nicht zum Deckungspreisdatum passt.
        if (!passtVertragsdatumZuDeckungspreisdatum(vertragsId, deckungsartId, deckungsbetrag)) {
            throw new DeckungspreisNichtVorhandenException(deckungsbetrag);
        }

        // Ablehnungsregel: Alter
        if (!deckungsartPasstZuAlter(vertragsId, deckungsartId, deckungsbetrag)) {
            throw new DeckungsartNichtRegelkonformException(deckungsartId);
        }

        speichereDeckung(vertragsId, deckungsartId, deckungsbetrag);

        L.info("[createDeckung] ende");
    }

    private boolean existiertVertragIDInDB(Integer id) {
        L.info("[existiertVertragIDInDB] id: " + id);
        String sql = "select * from Vertrag where ID=?";
        L.info("[existiertVertragIDInDB] sql: " + sql);
        try (PreparedStatement ps = useConnection().prepareStatement(sql)) {
            ps.setInt(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            L.error("", e);
            throw new DataException(e);
        }
    }

    private boolean existiertDeckungsartInDB(Integer id) {
        L.info("[existiertDeckungsartInDB] id: " + id);
        String sql = "select * from Deckungsart where ID=?";
        L.info("[existiertDeckungsartInDB] sql: " + sql);
        try (PreparedStatement ps = useConnection().prepareStatement(sql)) {
            ps.setInt(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            L.error("", e);
            throw new DataException(e);
        }
    }

    private boolean deckungsartPasstZuProdukt(Integer vertragsId, Integer deckungsartId) {
        L.info("[deckungsartPasstZuProdukt] vertragsId: " + vertragsId + " deckungsartId: " + deckungsartId);
        String sql = "select * from  Vertrag v join Deckungsart d on v.Produkt_FK = d.Produkt_FK where v.ID=? and d.ID=?";
        L.info("[deckungsartPasstZuProdukt] sql: " + sql);
        try (PreparedStatement ps = useConnection().prepareStatement(sql)) {
            ps.setInt(1, vertragsId);
            ps.setInt(2, deckungsartId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            L.error("", e);
            throw new DataException(e);
        }
    }

    private boolean existiertDeckungsbetragInDB(Integer deckungsartId) {
        L.info("[existiertDeckungsbetragInDB] deckungsartId: " + deckungsartId);
        String sql = "select * from deckungsbetrag where Deckungsart_FK=?";
        L.info("[existiertDeckungsbetragInDB] sql: " + sql);
        try (PreparedStatement ps = useConnection().prepareStatement(sql)) {
            ps.setInt(1, deckungsartId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            throw new DataException(e);
        }
    }

    private boolean existiertDeckungsbetragInDB(Integer deckungsartId, BigDecimal deckungsbetrag) {
        L.info("[existiertDeckungsbetragInDB] deckungsartId: " + deckungsartId + " deckungsbetrag: " + deckungsbetrag);
        String sql = "select * from deckungsbetrag where Deckungsart_FK=? and Deckungsbetrag=?";
        L.info("[existiertDeckungsbetragInDB] sql: " + sql);
        try (PreparedStatement ps = useConnection().prepareStatement(sql)) {
            ps.setInt(1, deckungsartId);
            ps.setBigDecimal(2, deckungsbetrag);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            throw new DataException(e);
        }
    }

    private boolean exisitiertDeckungspreisFürDeckungsbetrag(Integer deckungsartId) {
        L.info("[exisitiertDeckungspreis] deckungsartId: " + deckungsartId);
        String sql = "select * from Deckungsbetrag db join Deckungspreis dp on db.ID = dp.Deckungsbetrag_FK where db.Deckungsart_FK=?";
        L.info("[exisitiertDeckungspreis] sql: " + sql);
        try (PreparedStatement ps = useConnection().prepareStatement(sql)) {
            ps.setInt(1, deckungsartId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            throw new DataException(e);
        }
    }

    private boolean passtVertragsdatumZuDeckungspreisdatum(Integer vertragsId, Integer deckungsartId, BigDecimal deckungsbetrag) {
        L.info("[passtVertragsdatumZuDeckungspreisdatum] vertragsId: " + vertragsId + " deckungsartId: " + deckungsartId + " deckungsbetrag: " + deckungsbetrag);
        String sqlVertrag = "select Versicherungsbeginn, Versicherungsende from Vertrag where ID=?";
        String sqlDeckungspreis = "select Gueltig_Von, Gueltig_Bis from Deckungsbetrag db join Deckungspreis dp on db.ID = dp.Deckungsbetrag_FK where db.Deckungsart_FK=? and db.Deckungsbetrag=?";
        L.info("[passtVertragsdatumZuDeckungspreisdatum] sqlVertrag: " + sqlVertrag);
        L.info("[passtVertragsdatumZuDeckungspreisdatum] sqlDeckungspreis: " + sqlDeckungspreis);
        try (PreparedStatement psVertrag = useConnection().prepareStatement(sqlVertrag);
             PreparedStatement psDeckungspreis = useConnection().prepareStatement(sqlDeckungspreis)) {
            psVertrag.setInt(1, vertragsId);
            psDeckungspreis.setInt(1, deckungsartId);
            psDeckungspreis.setBigDecimal(2, deckungsbetrag);
            try (ResultSet rsVertrag = psVertrag.executeQuery();
                 ResultSet rsDeckungspreis = psDeckungspreis.executeQuery()) {
                rsVertrag.next();
                Date versicherungsbeginn = rsVertrag.getDate("Versicherungsbeginn");
                Date versicherungsende = rsVertrag.getDate("Versicherungsende");
                boolean versicherungsbeginnOK = false;
                boolean versicherungsendeOK = false;
                while (rsDeckungspreis.next()) {
                    Date gueltigVon = rsDeckungspreis.getDate("Gueltig_Von");
                    Date gueltigBis = rsDeckungspreis.getDate("Gueltig_Bis");
                    if (versicherungsbeginn.compareTo(gueltigVon) >= 0 && versicherungsbeginn.compareTo(gueltigBis) <= 0) {
                        versicherungsbeginnOK = true;
                    }
                    if (versicherungsende.compareTo(gueltigVon) >= 0 && versicherungsende.compareTo(gueltigBis) <= 0) {
                        versicherungsendeOK = true;
                    }
                }
                return versicherungsbeginnOK && versicherungsendeOK;
            }
        } catch (SQLException e) {
            throw new DataException(e);
        }
    }

    private boolean deckungsartPasstZuAlter(Integer vertragsId, Integer deckungsartId, BigDecimal deckungsbetrag) {
        L.info("[deckungsartPasstZuAlter] vertragsId: " + vertragsId + " deckungsartId: " + deckungsartId + " deckungsbetrag: " + deckungsbetrag);
        String sqlGeburtsdatum = "select k.Geburtsdatum, v.Versicherungsbeginn, v.Versicherungsende from Kunde k join Vertrag v on k.ID = v.Kunde_FK where v.ID=?";
        String sqlAblehnungsregel = "select R_Alter, R_Betrag from Ablehnungsregel where Deckungsart_FK=?";
        L.info("[deckungsartPasstZuAlter] sqlGeburtsdatum: " + sqlGeburtsdatum);
        L.info("[deckungsartPasstZuAlter] sqlAblehnungsregel: " + sqlAblehnungsregel);
        try (PreparedStatement psGeburtsdatum = useConnection().prepareStatement(sqlGeburtsdatum);
             PreparedStatement psAblehnungsregel = useConnection().prepareStatement(sqlAblehnungsregel)) {
            psGeburtsdatum.setInt(1, vertragsId);
            psAblehnungsregel.setInt(1, deckungsartId);
            try (ResultSet rsGeburtsdatum = psGeburtsdatum.executeQuery();
                 ResultSet rsAblehnungsregel = psAblehnungsregel.executeQuery()) {
                rsGeburtsdatum.next();
                Date geburtsdatum = rsGeburtsdatum.getDate("Geburtsdatum");
                Date versicherungsbeginn = rsGeburtsdatum.getDate("Versicherungsbeginn");
                while (rsAblehnungsregel.next()) {
                    String ablehnungsregelAlterString = rsAblehnungsregel.getString("R_Alter");
                    String ablehnungsregelBetragString = rsAblehnungsregel.getString("R_Betrag");
                    long differenceInYears = ChronoUnit.YEARS.between(geburtsdatum.toLocalDate(), versicherungsbeginn.toLocalDate());
                    if (ablehnungsregelAlterString.contains("<")) {
                        if (ablehnungsregelBetragString.equals("- -") && differenceInYears < Long.parseLong(ablehnungsregelAlterString.split(" ")[1])) {
                            return false;
                        }
                    } else if (ablehnungsregelAlterString.contains(">")) {
                        if (ablehnungsregelBetragString.equals("- -")) {
                            if (differenceInYears > Long.parseLong(ablehnungsregelAlterString.split(" ")[1])) {
                                return false;
                            }
                        } else {
                            long ablehnungsregelAlter = Long.parseLong(ablehnungsregelAlterString.split(" ")[1]);
                            BigDecimal ablehnungsregelBetrag = new BigDecimal(ablehnungsregelBetragString.split(" ")[1]);
                            if (deckungsbetrag.compareTo(ablehnungsregelBetrag) >= 0) {
                                if (differenceInYears > ablehnungsregelAlter) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            }
        } catch (SQLException e) {
            throw new DataException(e);
        }
    }

    private void speichereDeckung(Integer vertragsId, Integer deckungsartId, BigDecimal deckungsbetrag) {
        L.info("[speichereDeckung] vertragsId: " + vertragsId + " deckungsartId: " + deckungsartId + " deckungsbetrag: " + deckungsbetrag);
        String sql = "insert into Deckung (Vertrag_FK, Deckungsart_FK, Deckungsbetrag) values (?,?,?)";
        L.info("[speichereDeckung] sql: " + sql);
        try (PreparedStatement ps = useConnection().prepareStatement(sql)) {
            ps.setInt(1, vertragsId);
            ps.setInt(2, deckungsartId);
            ps.setBigDecimal(3, deckungsbetrag);
            ps.executeUpdate();
        } catch (SQLException e) {
            L.error("", e);
            throw new DataException(e);
        }
    }


}